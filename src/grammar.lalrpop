use crate::ast::*;

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    "fun", "val", "type",
    "true" => TRUE,
    "false" => FALSE,
    "if", "else",
    "&&", "||",
    "<", "<=", "!=", "==", ">=", ">",
    ",", ":",
    "(", ")",
    "{", "}",
    "->",
    "=",
    "*", "/", "+", "-",
    ";",
} else {
    r"[a-z_][a-zA-Z_0-9]*" => ID,
    r"[A-Z][a-zA-Z_0-9]*" => TID,
    r"-?[0-9]+" => INT,
    r"-?[0-9]+\.[0-9]*" => FLOAT,
    r#"".*""# => STRING,
}

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => { v.push(e); v }
    }
};

Arrow<T>: Vec<T> = { // (1)
    <mut v:(<T> "->")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => { v.push(e); v }
    }
};

Id: String =
    ID => <>.to_string();

Tid: String =
    TID => <>.to_string();

Type: Type<String> = {
    <Tid> => Type::Simple(<>),
    "(" <Arrow<Type>> ")" => Type::Function(<>),
};

TypedId: (String, Type<String>) =
    <id:Id> ":" <t:Type> => (id, t);

Lit: Lit = {
    INT => Lit::Int(str::parse(<>).unwrap()),
    FLOAT => Lit::Float(<>.to_string()),
    TRUE => Lit::Bool(true),
    FALSE => Lit::Bool(false),
    STRING => Lit::String(<>.to_string()),
};

Expr0: untyped::Expr = {
    "(" <Expr> ")",
};

Expr1: untyped::Expr = {
    <Fun> => untyped::Expr::Function(Box::new(<>), ()),
    <id:Tid> "{" <args:Comma<Expr>> "}"
        => Expr::New(id, args),
    <Expr0>,
};

Expr2: untyped::Expr = {
    <id: Id> "(" <args: Comma<Expr>> ")"
        => Expr::Call(id, args),
    <id:Id> => Expr::Value(id),
    <Lit> => Expr::Lit(<>),
    <Expr1>,
};

Expr3: untyped::Expr = {
    <lh:Expr3> "*" <rh:Expr2> => get_binop(Op::Mul)(<>),
    <lh:Expr3> "/" <rh:Expr2> => get_binop(Op::Div)(<>),
    <Expr2>,
};

Expr4: untyped::Expr = {
    <lh:Expr4> "+" <rh:Expr3> => get_binop(Op::Add)(<>),
    <lh:Expr4> "-" <rh:Expr3> => get_binop(Op::Sub)(<>),
    <Expr3>,
};

Expr5: untyped::Expr = {
    <lh:Expr5> "<" <rh:Expr4> => get_binop(Op::Lt)(<>),
    <lh:Expr5> "<=" <rh:Expr4> => get_binop(Op::Le)(<>),
    <lh:Expr5> "!=" <rh:Expr4> => get_binop(Op::Ne)(<>),
    <lh:Expr5> "==" <rh:Expr4> => get_binop(Op::Eq)(<>),
    <lh:Expr5> ">=" <rh:Expr4> => get_binop(Op::Ge)(<>),
    <lh:Expr5> ">" <rh:Expr4> => get_binop(Op::Gt)(<>),
    <Expr4>,
}

Expr6: untyped::Expr = {
    <lh:Expr6> "&&" <rh:Expr5> => get_binop(Op::And)(<>),
    <lh:Expr6> "||" <rh:Expr5> => get_binop(Op::Or)(<>),
    <Expr5>,
}

Expr7: untyped::Expr = {
    <Expr6>,
};

Expr8: untyped::Expr = {
    "val" <tid:TypedId> "=" <expr:Expr7>
        => Expr::Assign(tid, Box::new(expr)),
    <Expr7>
};

Expr9: untyped::Expr = {
    <lh:Expr9> ";" <rh:Expr8>
        => Expr::Chain(Box::new(lh), Box::new(rh)),
    <Expr8>,
};

pub Expr: untyped::Expr = {
    "if" <be:Expr> "{" <e1:Expr9> "}" "else" "{" <e2:Expr9> "}"
        => Expr::If(Box::new(be), Box::new(e1), Box::new(e2)),
    <id:Id> "->" <attr:Id>
        => Expr::Attr(id, (), attr),
    <Expr9>,
};

pub Fun: untyped::Fun = {
    "fun" <name:Id> "(" <args:Comma<TypedId>> ")" ":" <rt: Type> "{" <body:Expr> "}"
        => Fun {<>},
};

Struct: untyped::Struct = {
    "type" <name:Tid> "{" <args:Comma<TypedId>> "}"
        => Struct { name, args },
};

Decl: untyped::Decl = {
    <Fun> => Decl::Fun(<>),
    <Struct> => Decl::Struct(<>),
}

pub Mod: Vec<untyped::Decl> =
    <Decl*>;
