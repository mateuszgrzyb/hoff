use crate::ast::{Fun, Expr, Lit, get_binop, Op};

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    "fun", "val",
    ",", ":",
    "(", ")",
    "{", "}",
    "=",
    "*", "/", "+", "-",
    ";",
} else {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => ID,
    r"-?[0-9]+" => NUM,
}

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => { v.push(e); v }
    }
};

Id: String =
    ID => <>.to_string();

Num: i32 =
    NUM => str::parse(<>).unwrap();

Lit: Lit = {
    <Num> => Lit::Num(<>),
};

Expr0: Expr = {
    "(" <Expr> ")",
};

Expr1: Expr = {
    <Fun> => Expr::Function(Box::new(<>)),
    <Expr0>,
};

Expr2: Expr = {
    <id: Id> => Expr::Value(id),
    <Lit> => Expr::Lit(<>),
    <Expr1>,
};

Expr3: Expr = {
    <lh:Expr3> "*" <rh:Expr2> => get_binop(Op::Mul)(<>),
    <lh:Expr3> "/" <rh:Expr2> => get_binop(Op::Div)(<>),
    <Expr2>,
};

Expr4: Expr = {
    <lh:Expr4> "+" <rh:Expr3> => get_binop(Op::Add)(<>),
    <lh:Expr4> "-" <rh:Expr3> => get_binop(Op::Sub)(<>),
    <Expr3>,
};

Expr5: Expr = {
    "val" <id: Id> "=" <expr: Expr5> => Expr::Assign(id, Box::new(expr)),
    <Expr4>
};

Expr6: Expr = {
    <lh:Expr6> ";" <rh:Expr4> => Expr::Chain(Box::new(lh), Box::new(rh)),
    <Expr5>,
};

Expr7: Expr = {
    <Expr6>
}

pub Expr: Expr = <Expr7>;

pub Fun: Fun =
    "fun" <name: Id> "(" <args: Comma<Id>> ")" "{" <body: Expr> "}"
        => Fun { name, args, body };

pub Mod: Vec<Fun> = <Fun*>;
